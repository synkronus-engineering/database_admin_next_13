

create table
  public.profiles (
    id uuid not null,
    username text null,
    avatar_url text null,
    name text null,
    updated_at timestamp with time zone null,
    constraint profiles_pkey primary key (id),
    constraint profiles_username_key unique (username),
    constraint profiles_id_fkey foreign key (id) references auth.users (id),
    constraint username_length check ((char_length(username) >= 3))
  ) tablespace pg_default;
  
create table
  public.blog (
    id bigint generated by default as identity,
    user_id uuid null,
    title text null,
    content text null,
    views text[] null,
    likes text[] null,
    created_at timestamp with time zone null default now(),
    image_src text null,
    category text null,
    sort_description text null,
    author json null,
    constraint blog_pkey primary key (id),
    constraint blog_user_id_fkey foreign key (user_id) references profiles (id)
  ) tablespace pg_default;

create table
  public.article_comments (
    id bigint generated by default as identity,
    created_at timestamp with time zone null default now(),
    user_id uuid not null,
    comment text null,
    blog_id bigint not null,
    replies json[] null,
    constraint blog_comments_pkey primary key (id),
    constraint article_comments_blog_id_fkey foreign key (blog_id) references blog (id),
    constraint article_comments_user_id_fkey foreign key (user_id) references profiles (id)
  ) tablespace pg_default;

-- drop function update_likes_array
CREATE OR REPLACE FUNCTION update_likes_array(userid text, like_it boolean, blog_id int)
RETURNS void AS
$$
BEGIN
    IF like_it THEN
        -- Add user_id to the likes array if it doesn't already exist
        IF NOT EXISTS (SELECT 1 FROM public.blog WHERE id = blog_id AND likes @> ARRAY[userid]) THEN
            UPDATE public.blog SET likes = COALESCE(likes, '{}'::text[]) || ARRAY[userid] WHERE id = blog_id;
        END IF;
    ELSE
        -- Remove user_id from the likes array if it exists
        IF EXISTS (SELECT 1 FROM public.blog WHERE id = blog_id AND likes @> ARRAY[userid]) THEN
            UPDATE public.blog SET likes = array_remove(likes, userid) WHERE id = blog_id;
        END IF;
    END IF;
END;
$$
LANGUAGE plpgsql;

-- drop function insert_reply_to_comments
CREATE OR REPLACE FUNCTION insert_reply_to_comments(article_id bigint, reply_obj json)
RETURNS void AS
$$
DECLARE
    existing_replies json[];
BEGIN
    -- Fetch the existing replies for the specified blog_id
    SELECT replies INTO existing_replies
    FROM public.article_comments
    WHERE id = article_id;
    -- Append the new reply_obj to the existing replies
    existing_replies := COALESCE(existing_replies, '{}'::json[]) || reply_obj;
    -- Update the replies column with the updated replies
    UPDATE public.article_comments
    SET replies = existing_replies
    WHERE id = article_id;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION insert_article_views(blog_id bigint, anon_ssn text)
RETURNS boolean AS
$$
BEGIN
    -- Add user_id to the views array if it doesn't already exist
    IF NOT EXISTS (SELECT 1 FROM public.blog WHERE id = blog_id AND views @> ARRAY[anon_ssn]) THEN
        UPDATE public.blog SET views = COALESCE(views, '{}'::text[]) || ARRAY[anon_ssn] WHERE id = blog_id;
    END IF;

     -- Check if the update was successful and return true, otherwise return false
    IF FOUND THEN
        RETURN true;
    ELSE
        RETURN false;
    END IF;

END;
$$
LANGUAGE plpgsql;


 create function public.handle_new_user()
 returns trigger as $$
 begin
   insert into public.profiles (id, name, avatar_url, username)
   values (
    new.id, new.raw_user_meta_data->>'full_name', 
    new.raw_user_meta_data->>'avatar_url', 
    new.raw_user_meta_data->>'email');
   return new;
 end;
 $$ language plpgsql security definer;
 
 create trigger on_auth_user_created
   after insert on auth.users
   for each row execute procedure public.handle_new_user();